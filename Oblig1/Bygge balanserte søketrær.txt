Bygge balanserte søketrær

a) Ideen for algoritmen er å først skrive ut medianen i arrayet som rot. Deretter dele arrayet i to halvdeler og skrive ut medianen i hver halvdel som "rot" for sitt deltre. Og gjenta delingen og fortsette på samme måte til vi til slutt har gått gjennom hele listen (at low_index overskrider high_index). Treet blir balansert på denne måten fordi medianen i hver liste har samme antall elementer på hver side. 

PSEUDOKODE
Algorithm: Skriv ut tallene i en rekkefølge slik at vanlig 
innsetting i et BST gir et (helt) balansert tre.
Input: Sortert array A med n heltall.
Output: En rekkefølge som garanterer et balansert tre.

Procedure balancearray(A, low_index, high_index)
    if low_index > high_index then
        return

    mid = (low_index + high_index)/2
    print A[mid]

    balanceArray(A, low_index, mid-1)
    balanceArray(A, mid+1, high_index)

KJØREKOMMANDO:
javac BalanceArray.java
#test-eksempel
seq 20|java BalanceArray|java BalanceChecker


b) Ideen bak algoritmen er samme som over, bare at egenskapene til en prioritetskø gjør at vi må putte nedre (venstre) halvdel inn i en ny kø slik at første element i høyre kø gir medianen.  

PSEUDOKODE
Algorithm: Skriv ut tallene i en rekkefølge slik at vanlig 
innsetting i et BST gir et (helt) balansert tre.
Input: Prioritetskø Q med n heltall.
Output: En rekkefølge som garanterer et balansert tre.

Procedure balanceHeap(Q):
    If Q = null then
        return

    k ← |Q| / 2

    left ← new PriorityQueue()     
    For i ← 1 to k:
        left.add(Q.poll())

    m ← Q.poll()
    Print m

    balanceHeap(left)
    balanceHeap(Q)

KJØREKOMMANDO:
javac BalanceHeap.java
#test-eksempel
seq 20|java BalanceHeap|java BalanceChecker